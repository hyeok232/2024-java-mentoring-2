# private final
- private 생성자: 해당 클래스의 인스턴스(클래스로부터 생성된 객체) 생성을 제한하는데 사용. 데이터 은닉에 이용.
- final: 불변하도록 만드는것이 아닌 재할당 할 수 없도록 만드는것. 이는 상수처럼 작동한다.인스턴스 자체를 바꾸는것은 불가능이지만 인스턴스 내부의 값은 변경 가능.

- private final은 직접적으로 값을 참조할 수 없지만 생성자를 통해 값을 참조 할 수 있다.
  변수를 사용하면 재할당 못하며, 해당 필드,메서드 별 호출시에 새로이 값이 할당(인스턴스)된다.
  객체 생성시에 private final 변수는 초기화가 가능하다.
  이를 사용하는 이유는 클래스 내부에서만 접근 가능한 고정된 값을 만들 수 있다는 점에서 사용한다.

- private static final은 생성자를 통해 값을 참조 할 수 있다. 변수는 무조건 초기화 되어있어야 한다.
  즉, 절대 해당 값을 바꾸지 않겠다는 표현과 유사하다. 변수 사용시 재할당 하지 못하며 메모리에 한 번 올라가면 같은 값을 클래스 내부의 전체 필드
  메서드에서 공유한다.

# 의존성 주입 방법

- 생성자란?  객체를 생성할때 값을 넣어주는 역할을 하는것

- 생성자 주입: 생성자를 통해 의존 관계를 주입하는 방법. 생성자의 호출 시점에 1회 호출되는 것이 보장.
  그렇기 때문에 주입받은 객체가 변하지 않거나, 반드시 객체의 주입이 필요한 경우에 강제하기 위해 사용될 수 있다.

- 수정자 주입: setter 주입이라고도 한다. 필드 값을 변경하는 Setter를 통해서 의존 관계를 주입하는 방법이다.
  생성자 주입과 다르게 주입 받는 객체가 변경될 가능성이 있는 경우에 사용한다.(거의 사용할 필요 X)

- 필드 주입: 필드에 바로 의존 관계를 주입하는 방법이다. 필드 주입을 이용하면 코드가 간결해져서 과거에 많이 이용했으나,
  외부에서 접근이 불가능하다는 단점이 존재하고 테스트 코드의 중요성이 증가함에 따라 필드의 객체를 수정 할 수 없는 필드 주입은 거의 사용되지 않는다.

- 일반 메소드 주입: 일반 메소드를 통해 의존 관계를 주입하는 방법. (거의 사용 할 필요 X)

- 생성자 주입을 사용해야 하는 이유: 객체의 불변성 확보가 있다. 개발시 의존 관걔의 변경이 필요한 경우는 거의 없다. 하지만 수정자 주입이나
  메소드 주입을 이용하면 불필요한 수정의 가능성을 열어 유지보수가 어렵다. 그러므로 생성자 주입을 통해 변경의 가능성을 배제하고 불변성을 보장하는것이 좋다.

# 상수와 상수화
- 상수: 항상 유지되는 수(변하지 않는 수)

- 변수의 상수화: 변수에 저장된 값을 변경하지 않고 상수처럼 사용하는 것 (변수를 사용하면 초기화 이후 값을 바꿀 수 없다.)

- 상수화 방법: final 자료형 변수명 = 값;

- 사용 이유

- 1.변경 방지: 상수화된 변수는 초기화 후 변경 불가이므로, 변경 방지의 기능을 지님

- 2.유지 보수 용이: 상수를 사용하면 나중에 값이 변경될 경우, 해당 상수만 수정하면 되어 코드의 유지 보수가 더 쉬움.

- 3.코드의 일관성: 여러 클래스에서 동일한 값을 사용해야 할 경우, 상수로 정의하면 모든 클래스에서 동일한 값을 참조하게 되어 일관성을 가짐.

- 객체지향 관점에서 -> 유지보수, 로직 구현이 어렵다 라는 관점이 가장 크기때문에 객체지향관점에서는 유지보수 용이가 크고, 일관성은 동일한 값에 포커싱

# 개행
- 마지막 줄 개행 추가의 이유

- 1.가독성 향상( 마지막에 개행이 있으면, 여러 코드를 연결하거나 합칠 때 더 나은 가독성을 보임. )

- 2.호환성( 일부 도구에서 마지막 개행이 없으면 오류를 보일 수 있음. Git과 같은 버전 관리 시스템에서 마지막 라인이 개행으로 끝나지 않으면 경고 메시지를 표시)
  -> 협업시 마지막 줄 개행이 없으면 오류가 발생 할 수 있기때문에 주의!

- 개행 설정 옵션: file -> setting -> editor -> general 클릭 -> on save에서 ensure every saved file ends with a line break
